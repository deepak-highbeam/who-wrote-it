// Package github provides GitHub PR comment generation and posting.
// It generates compact, insight-driven Markdown collaboration summaries
// from ProjectReport data and posts them to PRs via the GitHub REST API.
package github

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/anthropic/who-wrote-it/internal/report"
)

// GenerateComment produces a Markdown PR comment body from a ProjectReport.
// The comment is compact and insight-driven: headline metric, work-type
// breakdown table with callouts, and top notable files.
func GenerateComment(pr *report.ProjectReport) string {
	var b strings.Builder

	// 1. Header.
	b.WriteString("## Who Wrote It - Collaboration Summary\n\n")

	// 2. Headline with spectrum counts inline.
	totalEvents := 0
	for _, count := range pr.ByAuthorship {
		totalEvents += count
	}
	fullyAI := pr.ByAuthorship["fully_ai"]
	aiFirst := pr.ByAuthorship["ai_first_human_revised"]
	humanFirst := pr.ByAuthorship["human_first_ai_revised"]
	fullyHuman := pr.ByAuthorship["fully_human"]

	b.WriteString(fmt.Sprintf("**Meaningful AI: %.1f%%** &mdash; ", pr.MeaningfulAIPct))
	b.WriteString(fmt.Sprintf("%d fully AI, %d AI-first, %d human-first, %d fully human",
		fullyAI, aiFirst, humanFirst, fullyHuman))
	b.WriteString(fmt.Sprintf(" (%d events across %d files)\n\n", totalEvents, pr.TotalFiles))

	// 3. Work-type breakdown table.
	b.WriteString("### Work Type Breakdown\n\n")
	b.WriteString("| Work Type | Tier | Files | AI% |\n")
	b.WriteString("|-----------|------|------:|----:|\n")

	wtOrder := []string{"architecture", "core_logic", "bug_fix", "edge_case", "boilerplate", "test_scaffolding"}
	for _, wt := range wtOrder {
		summary, ok := pr.ByWorkType[wt]
		if !ok {
			continue
		}
		b.WriteString(fmt.Sprintf("| %s | %s | %d | %.1f%% |\n",
			wt, summary.Tier, summary.Files, summary.AIPct))
	}
	b.WriteString("\n")

	// Insight callouts (1-3 max, only noteworthy patterns).
	var callouts []string
	if bp, ok := pr.ByWorkType["boilerplate"]; ok && bp.AIPct > 80 {
		callouts = append(callouts, fmt.Sprintf("> Heavy AI usage in boilerplate (%.0f%%) -- expected for scaffolding code", bp.AIPct))
	}
	if cl, ok := pr.ByWorkType["core_logic"]; ok && cl.AIPct < 30 {
		callouts = append(callouts, fmt.Sprintf("> Core logic is %.0f%% human-written", 100-cl.AIPct))
	}
	if cl, ok := pr.ByWorkType["core_logic"]; ok && cl.AIPct > 80 {
		callouts = append(callouts, fmt.Sprintf("> Core logic is %.0f%% AI-written -- review recommended", cl.AIPct))
	}
	if arch, ok := pr.ByWorkType["architecture"]; ok && arch.AIPct > 70 {
		callouts = append(callouts, fmt.Sprintf("> Architecture decisions are %.0f%% AI-driven", arch.AIPct))
	}

	if len(callouts) > 3 {
		callouts = callouts[:3]
	}
	for _, c := range callouts {
		b.WriteString(c + "\n")
	}
	if len(callouts) > 0 {
		b.WriteString("\n")
	}

	// 4. Top 3-5 notable files (by AI% desc, skip files with < 3 events).
	var notable []report.FileReport
	for _, f := range pr.Files {
		if f.TotalEvents >= 3 {
			notable = append(notable, f)
		}
	}
	// Already sorted by AI% desc from report generation.
	maxNotable := 5
	if len(notable) < maxNotable {
		maxNotable = len(notable)
	}

	if maxNotable > 0 {
		b.WriteString("### Notable Files\n\n")
		b.WriteString("| File | Work Type | AI% | Collaboration Pattern |\n")
		b.WriteString("|------|-----------|----:|----------------------|\n")

		for _, f := range notable[:maxNotable] {
			// Find the authorship level with the highest count.
			topLevel := ""
			topCount := 0
			for level, count := range f.AuthorshipCounts {
				if count > topCount {
					topLevel = level
					topCount = count
				}
			}
			fileName := f.FilePath
			if len(fileName) > 50 {
				fileName = "..." + fileName[len(fileName)-47:]
			}
			b.WriteString(fmt.Sprintf("| `%s` | %s | %.1f%% | %s |\n",
				fileName, f.WorkType, f.MeaningfulAIPct, topLevel))
		}
		b.WriteString("\n")
	}

	// 5. Footer.
	b.WriteString("---\n_Generated by [who-wrote-it](https://github.com/anthropic/who-wrote-it)_\n")

	return b.String()
}

// PostComment posts a comment body to a GitHub PR using the REST API.
// It sends a POST to https://api.github.com/repos/{owner}/{repo}/issues/{prNumber}/comments
// with Bearer token authentication. Returns an error with status code on failure.
func PostComment(owner, repo string, prNumber int, body string, token string) error {
	url := fmt.Sprintf("https://api.github.com/repos/%s/%s/issues/%d/comments", owner, repo, prNumber)

	payload := struct {
		Body string `json:"body"`
	}{Body: body}

	jsonData, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("marshal comment body: %w", err)
	}

	req, err := http.NewRequest("POST", url, bytes.NewReader(jsonData))
	if err != nil {
		return fmt.Errorf("create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("post comment: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		respBody, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("github API returned status %d: %s", resp.StatusCode, string(respBody))
	}

	return nil
}

// ParseGitHubRemote extracts the owner and repo from a GitHub remote URL.
// Supports both HTTPS and SSH formats:
//   - https://github.com/{owner}/{repo}.git (or without .git)
//   - git@github.com:{owner}/{repo}.git (or without .git)
func ParseGitHubRemote(remoteURL string) (owner, repo string, err error) {
	remoteURL = strings.TrimSpace(remoteURL)

	// Try HTTPS format: https://github.com/{owner}/{repo}[.git]
	httpsRe := regexp.MustCompile(`^https?://github\.com/([^/]+)/([^/]+?)(?:\.git)?$`)
	if matches := httpsRe.FindStringSubmatch(remoteURL); matches != nil {
		return matches[1], matches[2], nil
	}

	// Try SSH format: git@github.com:{owner}/{repo}[.git]
	sshRe := regexp.MustCompile(`^git@github\.com:([^/]+)/([^/]+?)(?:\.git)?$`)
	if matches := sshRe.FindStringSubmatch(remoteURL); matches != nil {
		return matches[1], matches[2], nil
	}

	return "", "", fmt.Errorf("unable to parse GitHub remote URL: %q", remoteURL)
}

// DetectPRNumber attempts to detect the current PR number.
// It checks, in order:
//  1. GITHUB_PR_NUMBER environment variable (for CI environments)
//  2. `gh pr view --json number` via exec.Command (for local development)
//
// Returns an error if neither method works.
func DetectPRNumber() (int, error) {
	// Check environment variable first (CI).
	if envPR := os.Getenv("GITHUB_PR_NUMBER"); envPR != "" {
		n, err := strconv.Atoi(envPR)
		if err != nil {
			return 0, fmt.Errorf("invalid GITHUB_PR_NUMBER %q: %w", envPR, err)
		}
		return n, nil
	}

	// Try gh CLI.
	out, err := exec.Command("gh", "pr", "view", "--json", "number").Output()
	if err != nil {
		return 0, fmt.Errorf("auto-detect PR number failed (set --pr flag or GITHUB_PR_NUMBER env var): %w", err)
	}

	var result struct {
		Number int `json:"number"`
	}
	if err := json.Unmarshal(out, &result); err != nil {
		return 0, fmt.Errorf("parse gh pr view output: %w", err)
	}

	if result.Number == 0 {
		return 0, fmt.Errorf("gh pr view returned PR number 0")
	}

	return result.Number, nil
}

// DetectRemoteURL runs `git remote get-url origin` to get the remote URL.
func DetectRemoteURL() (string, error) {
	out, err := exec.Command("git", "remote", "get-url", "origin").Output()
	if err != nil {
		return "", fmt.Errorf("get git remote URL: %w", err)
	}
	return strings.TrimSpace(string(out)), nil
}

// FormatSurvivalReport formats a SurvivalReport as a terminal-friendly string
// with ANSI colors. Placed here to avoid circular imports (survival imports store,
// not report).
func FormatSurvivalReport(sr *SurvivalReport) string {
	var b strings.Builder

	bold := "\033[1m"
	green := "\033[32m"
	yellow := "\033[33m"
	red := "\033[31m"
	reset := "\033[0m"

	colorRate := func(rate float64) string {
		switch {
		case rate >= 80:
			return green
		case rate >= 50:
			return yellow
		default:
			return red
		}
	}

	b.WriteString(bold + "Who Wrote It - Code Survival Report" + reset + "\n")
	b.WriteString(strings.Repeat("=", 40) + "\n\n")

	b.WriteString(fmt.Sprintf("Tracked AI lines: %d\n", sr.TotalTracked))
	b.WriteString(fmt.Sprintf("Survived:         %d\n", sr.SurvivedCount))
	b.WriteString(fmt.Sprintf("Survival rate:    %s%s%.1f%%%s\n\n",
		bold, colorRate(sr.SurvivalRate), sr.SurvivalRate, reset))

	// By authorship level.
	if len(sr.ByAuthorship) > 0 {
		b.WriteString(bold + "By Authorship Level" + reset + "\n")
		b.WriteString(strings.Repeat("-", 50) + "\n")
		b.WriteString(fmt.Sprintf("%-28s %8s %8s %7s\n", "Level", "Tracked", "Survived", "Rate"))
		b.WriteString(strings.Repeat("-", 50) + "\n")

		levels := []string{"fully_ai", "ai_first_human_revised"}
		for _, level := range levels {
			bd, ok := sr.ByAuthorship[level]
			if !ok {
				continue
			}
			b.WriteString(fmt.Sprintf("%-28s %8d %8d %s%6.1f%%%s\n",
				level, bd.Tracked, bd.Survived, colorRate(bd.Rate), bd.Rate, reset))
		}
		b.WriteString("\n")
	}

	// By work type.
	if len(sr.ByWorkType) > 0 {
		b.WriteString(bold + "By Work Type" + reset + "\n")
		b.WriteString(strings.Repeat("-", 50) + "\n")
		b.WriteString(fmt.Sprintf("%-18s %8s %8s %7s\n", "Work Type", "Tracked", "Survived", "Rate"))
		b.WriteString(strings.Repeat("-", 50) + "\n")

		wtOrder := []string{"architecture", "core_logic", "bug_fix", "edge_case", "boilerplate", "test_scaffolding"}
		for _, wt := range wtOrder {
			bd, ok := sr.ByWorkType[wt]
			if !ok {
				continue
			}
			b.WriteString(fmt.Sprintf("%-18s %8d %8d %s%6.1f%%%s\n",
				wt, bd.Tracked, bd.Survived, colorRate(bd.Rate), bd.Rate, reset))
		}
	}

	return b.String()
}

// SurvivalReport is defined in the survival package but duplicated here
// for formatting purposes to avoid circular imports. The survival package
// is the canonical definition.
type SurvivalReport struct {
	TotalTracked  int                          `json:"total_tracked"`
	SurvivedCount int                          `json:"survived_count"`
	SurvivalRate  float64                      `json:"survival_rate"`
	ByAuthorship  map[string]SurvivalBreakdown `json:"by_authorship"`
	ByWorkType    map[string]SurvivalBreakdown `json:"by_work_type"`
}

// SurvivalBreakdown holds survival statistics for a category.
type SurvivalBreakdown struct {
	Tracked  int     `json:"tracked"`
	Survived int     `json:"survived"`
	Rate     float64 `json:"rate"`
}

// sortedWorkTypes returns the canonical work type order for table output.
func sortedWorkTypes(m map[string]report.WorkTypeSummary) []string {
	order := []string{"architecture", "core_logic", "bug_fix", "edge_case", "boilerplate", "test_scaffolding"}
	var result []string
	for _, wt := range order {
		if _, ok := m[wt]; ok {
			result = append(result, wt)
		}
	}
	// Append any unknown work types alphabetically.
	var unknown []string
	for wt := range m {
		found := false
		for _, o := range order {
			if wt == o {
				found = true
				break
			}
		}
		if !found {
			unknown = append(unknown, wt)
		}
	}
	sort.Strings(unknown)
	result = append(result, unknown...)
	return result
}
