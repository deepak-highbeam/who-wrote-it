package github

import (
	"strings"
	"testing"

	"github.com/anthropic/who-wrote-it/internal/report"
)

func TestGenerateComment_BasicOutput(t *testing.T) {
	pr := &report.ProjectReport{
		ProjectPath:    "/myproject",
		MeaningfulAIPct: 65.5,
		RawAIPct:       70.0,
		TotalFiles:     4,
		ByAuthorship: map[string]int{
			"fully_ai":               5,
			"ai_first_human_revised": 2,
			"fully_human":            3,
		},
		ByWorkType: map[string]report.WorkTypeSummary{
			"core_logic":  {Files: 2, AIEvents: 4, TotalEvents: 5, AIPct: 80.0, Tier: "high", Weight: 3.0},
			"boilerplate": {Files: 2, AIEvents: 3, TotalEvents: 3, AIPct: 100.0, Tier: "low", Weight: 1.0},
		},
		Files: []report.FileReport{
			{
				FilePath:         "main.go",
				WorkType:         "core_logic",
				MeaningfulAIPct:  100.0,
				TotalEvents:      5,
				AIEventCount:     5,
				AuthorshipCounts: map[string]int{"fully_ai": 5},
			},
			{
				FilePath:         "util.go",
				WorkType:         "boilerplate",
				MeaningfulAIPct:  100.0,
				TotalEvents:      3,
				AIEventCount:     3,
				AuthorshipCounts: map[string]int{"fully_ai": 3},
			},
			{
				FilePath:         "handler.go",
				WorkType:         "core_logic",
				MeaningfulAIPct:  0.0,
				TotalEvents:      1,
				AIEventCount:     0,
				AuthorshipCounts: map[string]int{"fully_human": 1},
			},
		},
	}

	body := GenerateComment(pr)

	// Check required sections are present.
	checks := []string{
		"## Who Wrote It - Collaboration Summary",
		"**Meaningful AI: 65.5%**",
		"5 fully AI",
		"2 AI-first",
		"3 fully human",
		"### Work Type Breakdown",
		"core_logic",
		"boilerplate",
		"### Notable Files",
		"`main.go`",
		"`util.go`",
		"_Generated by [who-wrote-it]",
	}

	for _, check := range checks {
		if !strings.Contains(body, check) {
			t.Errorf("GenerateComment output missing %q\n\nFull output:\n%s", check, body)
		}
	}

	// handler.go has < 3 events, should NOT appear in notable files.
	if strings.Contains(body, "`handler.go`") {
		t.Error("handler.go should not appear in notable files (< 3 events)")
	}
}

func TestGenerateComment_InsightCallouts(t *testing.T) {
	pr := &report.ProjectReport{
		ProjectPath:    "/proj",
		MeaningfulAIPct: 30.0,
		TotalFiles:     2,
		ByAuthorship:   map[string]int{"fully_ai": 2, "fully_human": 4},
		ByWorkType: map[string]report.WorkTypeSummary{
			"core_logic":  {Files: 1, AIEvents: 0, TotalEvents: 4, AIPct: 0.0, Tier: "high", Weight: 3.0},
			"boilerplate": {Files: 1, AIEvents: 2, TotalEvents: 2, AIPct: 100.0, Tier: "low", Weight: 1.0},
		},
		Files: []report.FileReport{},
	}

	body := GenerateComment(pr)

	if !strings.Contains(body, "Heavy AI usage in boilerplate") {
		t.Error("expected boilerplate insight callout")
	}
	if !strings.Contains(body, "Core logic is 100% human-written") {
		t.Error("expected core logic human-written callout")
	}
}

func TestGenerateComment_NoNotableFiles(t *testing.T) {
	pr := &report.ProjectReport{
		ProjectPath:    "/proj",
		MeaningfulAIPct: 50.0,
		TotalFiles:     1,
		ByAuthorship:   map[string]int{"fully_ai": 1},
		ByWorkType: map[string]report.WorkTypeSummary{
			"core_logic": {Files: 1, AIEvents: 1, TotalEvents: 1, AIPct: 100.0, Tier: "high", Weight: 3.0},
		},
		Files: []report.FileReport{
			{FilePath: "tiny.go", TotalEvents: 1, AIEventCount: 1, AuthorshipCounts: map[string]int{"fully_ai": 1}},
		},
	}

	body := GenerateComment(pr)

	// tiny.go has only 1 event, should not show in notable files.
	if strings.Contains(body, "### Notable Files") {
		t.Error("should not show Notable Files section when no files have >= 3 events")
	}
}

func TestParseGitHubRemote_HTTPS(t *testing.T) {
	tests := []struct {
		url       string
		wantOwner string
		wantRepo  string
	}{
		{"https://github.com/anthropic/who-wrote-it.git", "anthropic", "who-wrote-it"},
		{"https://github.com/anthropic/who-wrote-it", "anthropic", "who-wrote-it"},
		{"http://github.com/user/repo.git", "user", "repo"},
	}

	for _, tt := range tests {
		owner, repo, err := ParseGitHubRemote(tt.url)
		if err != nil {
			t.Errorf("ParseGitHubRemote(%q) error: %v", tt.url, err)
			continue
		}
		if owner != tt.wantOwner || repo != tt.wantRepo {
			t.Errorf("ParseGitHubRemote(%q) = (%q, %q), want (%q, %q)",
				tt.url, owner, repo, tt.wantOwner, tt.wantRepo)
		}
	}
}

func TestParseGitHubRemote_SSH(t *testing.T) {
	tests := []struct {
		url       string
		wantOwner string
		wantRepo  string
	}{
		{"git@github.com:anthropic/who-wrote-it.git", "anthropic", "who-wrote-it"},
		{"git@github.com:anthropic/who-wrote-it", "anthropic", "who-wrote-it"},
		{"git@github.com:user/repo.git", "user", "repo"},
	}

	for _, tt := range tests {
		owner, repo, err := ParseGitHubRemote(tt.url)
		if err != nil {
			t.Errorf("ParseGitHubRemote(%q) error: %v", tt.url, err)
			continue
		}
		if owner != tt.wantOwner || repo != tt.wantRepo {
			t.Errorf("ParseGitHubRemote(%q) = (%q, %q), want (%q, %q)",
				tt.url, owner, repo, tt.wantOwner, tt.wantRepo)
		}
	}
}

func TestParseGitHubRemote_Invalid(t *testing.T) {
	invalids := []string{
		"",
		"not-a-url",
		"https://gitlab.com/user/repo",
		"ftp://github.com/user/repo",
	}

	for _, url := range invalids {
		_, _, err := ParseGitHubRemote(url)
		if err == nil {
			t.Errorf("ParseGitHubRemote(%q) expected error, got nil", url)
		}
	}
}

func TestFormatSurvivalReport_BasicOutput(t *testing.T) {
	sr := &SurvivalReport{
		TotalTracked:  100,
		SurvivedCount: 85,
		SurvivalRate:  85.0,
		ByAuthorship: map[string]SurvivalBreakdown{
			"fully_ai":               {Tracked: 60, Survived: 50, Rate: 83.3},
			"ai_first_human_revised": {Tracked: 40, Survived: 35, Rate: 87.5},
		},
		ByWorkType: map[string]SurvivalBreakdown{
			"core_logic":  {Tracked: 70, Survived: 60, Rate: 85.7},
			"boilerplate": {Tracked: 30, Survived: 25, Rate: 83.3},
		},
	}

	output := FormatSurvivalReport(sr)

	checks := []string{
		"Code Survival Report",
		"Tracked AI lines: 100",
		"Survived:         85",
		"85.0%",
		"fully_ai",
		"ai_first_human_revised",
		"core_logic",
		"boilerplate",
	}

	for _, check := range checks {
		if !strings.Contains(output, check) {
			t.Errorf("FormatSurvivalReport output missing %q", check)
		}
	}
}
