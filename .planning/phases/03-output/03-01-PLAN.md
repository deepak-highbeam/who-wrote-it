---
phase: 03-output
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/whowroteit/main.go
  - internal/report/report.go
  - internal/report/format.go
  - internal/report/report_test.go
autonomous: true

must_haves:
  truths:
    - "`whowroteit analyze` reads the SQLite store and prints a project-level summary with meaningful AI %, spectrum breakdown, and work-type distribution"
    - "`whowroteit analyze --file path/to/file` prints a single-file detailed breakdown"
    - "`whowroteit analyze --json` outputs machine-readable JSON"
    - "`whowroteit status` shows daemon status with uptime, data collection stats, and health info in a formatted table"
  artifacts:
    - path: "internal/report/report.go"
      provides: "Report generation from store data using metrics.Calculator and worktype.Classifier"
      exports: ["GenerateProject", "GenerateFile"]
    - path: "internal/report/format.go"
      provides: "Terminal table formatting with colors and JSON output mode"
      exports: ["FormatProjectReport", "FormatFileReport", "FormatStatus", "FormatJSON"]
    - path: "cmd/whowroteit/main.go"
      provides: "analyze and enhanced status cobra commands"
      contains: "analyzeCmd"
  key_links:
    - from: "cmd/whowroteit/main.go"
      to: "internal/report/report.go"
      via: "analyzeCmd calls report.GenerateProject or report.GenerateFile"
      pattern: "report\\.Generate"
    - from: "internal/report/report.go"
      to: "internal/store/sqlite.go"
      via: "opens store directly for offline queries (daemon not required)"
      pattern: "store\\.New"
    - from: "internal/report/report.go"
      to: "internal/metrics/calculator.go"
      via: "uses Calculator to compute meaningful AI %"
      pattern: "metrics\\.NewCalculator"
---

<objective>
Build the `analyze` CLI command and enhance the existing `status` command to produce rich, formatted attribution reports.

Purpose: Surface the intelligence built in Phase 2 through the CLI so users can see per-file and per-project authorship breakdown, work-type distribution, and meaningful AI percentages.

Output: `internal/report/` package with report generation and formatting, updated `cmd/whowroteit/main.go` with `analyze` command and enhanced `status` command.
</objective>

<execution_context>
@/Users/deepakbhimaraju/.claude/get-shit-done/workflows/execute-plan.md
@/Users/deepakbhimaraju/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/store/sqlite.go
@internal/metrics/calculator.go
@internal/worktype/patterns.go
@internal/authorship/classifier.go
@internal/ipc/protocol.go
@internal/ipc/client.go
@internal/config/config.go
@cmd/whowroteit/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Report generation package and formatting</name>
  <files>
    internal/report/report.go
    internal/report/format.go
    internal/report/report_test.go
  </files>
  <action>
Create a new `internal/report/` package with two files.

**report.go** -- Report data generation:
- `GenerateProject(dbPath string) (*ProjectReport, error)` -- Opens the store at dbPath (read-only, no daemon needed), calls `store.QueryAttributionsWithWorkType(projectPath)` for each project, uses `metrics.NewCalculator().ComputeProjectMetrics()` to get FileMetrics and ProjectMetrics. Returns a `ProjectReport` struct containing:
  - ProjectPath string
  - MeaningfulAIPct float64
  - RawAIPct float64
  - TotalFiles int
  - ByAuthorship map[string]int (spectrum: fully_ai, ai_first_human_revised, etc. -> count)
  - ByWorkType map[string]WorkTypeSummary (work_type -> {Files, AIEvents, TotalEvents, AIPct, Tier, Weight})
  - Files []FileReport sorted by MeaningfulAIPct descending
- `GenerateFile(dbPath string, filePath string) (*FileReport, error)` -- Same approach but for single file using `store.QueryAttributionsByFileWithWorkType(filePath)`.
- `FileReport` struct: FilePath, WorkType, MeaningfulAIPct, RawAIPct, AuthorshipCounts map[string]int, TotalEvents int, AIEventCount int
- To discover project paths from the DB, query `SELECT DISTINCT project_path FROM attributions`. If multiple, use the first (single-project v1).

**format.go** -- Terminal formatting:
- `FormatProjectReport(r *ProjectReport) string` -- Summary-first layout:
  1. Header: "Who Wrote It - Attribution Report"
  2. Headline metric: "Meaningful AI: XX.X%" (bold/colored if terminal supports it -- use ANSI codes directly, no external dep)
  3. Spectrum breakdown table: 5-level spectrum with counts and percentages
  4. Work-type distribution table: work type | tier | files | AI% | weight
  5. Top files sorted by AI%: file path | work type | AI% | events
  Use simple ANSI color codes: \033[1m for bold, \033[32m for green, \033[33m for yellow, \033[31m for red, \033[0m for reset. Color the AI% based on level: >70% red, 30-70% yellow, <30% green.
- `FormatFileReport(r *FileReport) string` -- Single file detail view with authorship breakdown counts
- `FormatStatus(status *ipc.StatusData) string` -- Formatted table for daemon status (replaces the current raw JSON dump): uptime, DB size (humanized bytes), file events, session events, git commits, watched paths
- `FormatJSON(v interface{}) string` -- JSON marshal with indent for --json flag
- Helper `humanBytes(b int64) string` to format bytes as KB/MB/GB

**report_test.go** -- Test that GenerateProject and GenerateFile correctly aggregate data:
- Create an in-memory store, insert test attributions with work types, verify ProjectReport fields match expected calculations
- Test FormatJSON produces valid JSON
  </action>
  <verify>
    Run `cd /Users/deepakbhimaraju/who-wrote-it && go build ./internal/report/` -- compiles successfully.
    Run `cd /Users/deepakbhimaraju/who-wrote-it && go test ./internal/report/` -- tests pass.
  </verify>
  <done>
    report.go exports GenerateProject and GenerateFile that read from store and produce structured report data.
    format.go exports FormatProjectReport, FormatFileReport, FormatStatus, FormatJSON for terminal output.
    Tests verify correct aggregation logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire analyze and enhanced status into CLI</name>
  <files>
    cmd/whowroteit/main.go
  </files>
  <action>
Update cmd/whowroteit/main.go to add the `analyze` command and enhance `status`:

**analyze command:**
- `whowroteit analyze` -- Default: generates full project report
  - Flag `--file string` -- Single file analysis
  - Flag `--json` -- Output as JSON instead of formatted table
  - Flag `--db string` -- Override DB path (default: from config)
- Implementation:
  1. Load config to get default DBPath
  2. If --file is set, call `report.GenerateFile(dbPath, filePath)`, then format with `report.FormatFileReport()` or `report.FormatJSON()`
  3. Otherwise, call `report.GenerateProject(dbPath)`, then format with `report.FormatProjectReport()` or `report.FormatJSON()`
  4. Print result to stdout
- This command reads the DB directly -- does NOT require the daemon to be running. This is important for offline analysis.

**Enhanced status command:**
- Replace the raw JSON dump in the existing `statusCmd()` with formatted output using `report.FormatStatus(status)`
- Keep the ability to get JSON output: add `--json` flag. If set, output the raw JSON (current behavior). Otherwise, use formatted table.

Add `rootCmd.AddCommand(analyzeCmd())` alongside existing commands.
  </action>
  <verify>
    Run `cd /Users/deepakbhimaraju/who-wrote-it && go build -o /dev/null ./cmd/whowroteit/` -- builds successfully.
    Run `cd /Users/deepakbhimaraju/who-wrote-it && go vet ./cmd/...` -- no issues.
  </verify>
  <done>
    `whowroteit analyze` command exists with --file, --json, and --db flags.
    `whowroteit status` shows formatted table by default, --json for machine output.
    Both commands compile and vet cleanly.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles the entire project without errors
2. `go test ./internal/report/` passes all tests
3. `go vet ./...` has no issues
4. Binary `whowroteit analyze --help` shows the analyze command with flags
5. Binary `whowroteit status --help` shows the status command
</verification>

<success_criteria>
- `whowroteit analyze` produces a formatted project attribution report reading from SQLite
- `whowroteit analyze --file X` produces a single-file detail report
- `whowroteit analyze --json` outputs machine-readable JSON
- `whowroteit status` shows a formatted table (not raw JSON)
- All tests pass, code compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-output/03-01-SUMMARY.md`
</output>
