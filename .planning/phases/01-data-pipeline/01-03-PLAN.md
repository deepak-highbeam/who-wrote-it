---
phase: 01-data-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/sessionparser/parser.go
  - internal/sessionparser/tailer.go
  - internal/sessionparser/discovery.go
  - internal/sessionparser/provider.go
  - internal/sessionparser/parser_test.go
  - internal/gitint/repository.go
  - internal/gitint/blame.go
  - internal/gitint/commits.go
  - internal/gitint/gitint_test.go
autonomous: true

must_haves:
  truths:
    - "Claude Code JSONL session files are discovered under ~/.claude/projects/ and tailed as new lines are appended"
    - "Write tool_use events are extracted with file path and content hash, stored in session_events table"
    - "New session files created during a session are detected and tailed automatically"
    - "Session parser is behind an interface that could be swapped for Copilot/Cursor parser"
    - "Git commits are parsed with author, message, timestamp, and Co-Authored-By detection"
    - "Git diffs show per-file additions/deletions and handle renamed files"
    - "Git blame provides line-level authorship for tracked files"
  artifacts:
    - path: "internal/sessionparser/provider.go"
      provides: "Interface for AI tool session parsing (abstraction layer)"
      exports: ["SessionProvider", "SessionEvent"]
    - path: "internal/sessionparser/parser.go"
      provides: "Claude Code JSONL parser implementation"
      exports: ["ClaudeCodeParser", "ParseLine"]
    - path: "internal/sessionparser/tailer.go"
      provides: "File tailing for live session monitoring"
      exports: ["Tailer", "Tail"]
    - path: "internal/sessionparser/discovery.go"
      provides: "Session file discovery under ~/.claude/projects/"
      exports: ["Discover", "WatchForNew"]
    - path: "internal/gitint/repository.go"
      provides: "Git repository wrapper using go-git"
      exports: ["Repository", "Open"]
    - path: "internal/gitint/commits.go"
      provides: "Commit parsing with Co-Authored-By detection"
      exports: ["ParseCommits", "DetectCoAuthor"]
    - path: "internal/gitint/blame.go"
      provides: "Git blame for line-level authorship"
      exports: ["BlameFile"]
  key_links:
    - from: "internal/daemon/daemon.go"
      to: "internal/sessionparser/discovery.go"
      via: "daemon starts session discovery on startup"
      pattern: "sessionparser\\.Discover"
    - from: "internal/sessionparser/tailer.go"
      to: "internal/store/sqlite.go"
      via: "tailer writes parsed events to store"
      pattern: "store\\.InsertSessionEvent"
    - from: "internal/sessionparser/parser.go"
      to: "internal/sessionparser/provider.go"
      via: "ClaudeCodeParser implements SessionProvider interface"
      pattern: "SessionProvider"
    - from: "internal/daemon/daemon.go"
      to: "internal/gitint/repository.go"
      via: "daemon initializes git integration"
      pattern: "gitint\\.Open"
    - from: "internal/gitint/commits.go"
      to: "internal/store/sqlite.go"
      via: "commits and diffs stored in git_commits and git_diffs tables"
      pattern: "store\\.InsertGitCommit"
---

<objective>
Build the Claude Code session parser (JSONL discovery, tailing, Write event extraction behind an abstraction layer) and git integration (commit parsing, blame, Co-Authored-By detection using go-git).

Purpose: Session data and git history are the two remaining input signals. Session data tells us WHAT the AI wrote. Git tells us what ultimately shipped and who gets credit in the commit history. Together with file events from Plan 02, all three signals are flowing.
Output: Session events and git data persisted in SQLite, completing the data pipeline.
</objective>

<execution_context>
@/Users/deepakbhimaraju/.claude/get-shit-done/workflows/execute-plan.md
@/Users/deepakbhimaraju/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-data-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Claude Code session parser with abstraction layer</name>
  <files>
    internal/sessionparser/provider.go
    internal/sessionparser/parser.go
    internal/sessionparser/tailer.go
    internal/sessionparser/discovery.go
    internal/sessionparser/parser_test.go
  </files>
  <action>
    **Abstraction layer (internal/sessionparser/provider.go):**
    - Define `SessionProvider` interface:
      ```go
      type SessionProvider interface {
          Name() string  // "claude-code", "copilot", etc.
          Discover(ctx context.Context) ([]SessionFile, error)
          WatchForNew(ctx context.Context, found chan<- SessionFile) error
          ParseLine(line []byte) (*SessionEvent, error)
      }
      ```
    - Define `SessionFile` struct: Path, SessionID, Provider string
    - Define `SessionEvent` struct: SessionID, EventType, ToolName, FilePath, ContentHash, Timestamp, RawJSON
    - This interface is the extensibility point -- future Copilot/Cursor parsers implement it.

    **Claude Code parser (internal/sessionparser/parser.go):**
    - Implements `SessionProvider` interface.
    - `ParseLine(line []byte)` parses a JSONL line from Claude Code session files.
    - Claude Code JSONL format: Each line is a JSON object. Look for entries where:
      - `type` is `"assistant"` and the message contains `tool_use` blocks
      - Within tool_use, `name` is `"Write"` (file write operations)
      - Extract `input.file_path` and `input.content` from the Write tool_use
    - Also extract: `"Read"` tool_use (file reads indicate context gathering), `"Bash"` tool_use (command execution)
    - Focus on Write events as primary signal (CCSP-02), but store all tool_use events for future correlation.
    - Compute SHA-256 content hash of written content for later dedup/matching.
    - Handle malformed lines gracefully: log warning, skip, continue (session files may have partial writes).

    **Session discovery (internal/sessionparser/discovery.go):**
    - `Discover(ctx context.Context)` scans `~/.claude/projects/` for JSONL session files.
    - Claude Code stores sessions at `~/.claude/projects/{project-hash}/{session-id}.jsonl` (may vary -- scan recursively for *.jsonl files).
    - Filter to sessions modified within last 24 hours for initial scan (configurable).
    - `WatchForNew(ctx context.Context, found chan<- SessionFile)` uses fsnotify on `~/.claude/projects/` to detect new session files as they appear (session rotation, CCSP-03).

    **File tailer (internal/sessionparser/tailer.go):**
    - `Tailer` struct that tails a file from a given offset, emitting new lines.
    - `Tail(ctx context.Context, path string, offset int64, lines chan<- []byte)` opens file, seeks to offset, reads new lines as they appear.
    - Uses polling (check file size every 500ms) rather than fsnotify for individual files -- more reliable for files being appended to by other processes.
    - Tracks last offset in store (`daemon_state` table) for resume after restart.
    - On context cancellation, records final offset and returns.

    **Store integration:**
    - Add `InsertSessionEvent(event SessionEvent) error` method to store.
    - Add `CountSessionEvents() (int64, error)` for status reporting.
    - Add `GetDaemonState(key string) (string, error)` and `SetDaemonState(key, value string) error` for offset tracking.

    **Daemon integration:**
    - On startup: call Discover() to find existing sessions, start Tailer for each active session (from last known offset), start WatchForNew() for session rotation.
    - For each tailed line: call parser.ParseLine(), if event returned insert into store.
    - On shutdown: stop all tailers (they save offsets), stop discovery watcher.

    **IMPORTANT:** Claude Code JSONL format has no stability contract (noted in STATE.md concerns). The parser should be defensive: unknown fields ignored, missing fields produce nil event (skip), version detection if possible. Log a warning on first unrecognized format but don't crash.
  </action>
  <verify>
    `go build ./...` compiles.
    Create a mock JSONL session file with sample Write tool_use events.
    Start daemon -- verify it discovers and tails the session file.
    Append a new Write tool_use line to the session file -- verify event appears in `session_events` table.
    `go test ./internal/sessionparser/ -v` -- parser tests pass for valid lines, malformed lines, and missing fields.
  </verify>
  <done>
    Session files are discovered, tailed, and parsed. Write tool_use events produce records in session_events table with file path and content hash. New session files are detected. Parser is behind SessionProvider interface. Malformed input is handled gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Git integration with go-git</name>
  <files>
    internal/gitint/repository.go
    internal/gitint/commits.go
    internal/gitint/blame.go
    internal/gitint/gitint_test.go
  </files>
  <action>
    **Repository (internal/gitint/repository.go):**
    - Use `github.com/go-git/go-git/v5` (pure Go git implementation, no CGO).
    - `Repository` struct wrapping go-git repository plus store reference.
    - `Open(repoPath string, store *store.Store)` opens existing git repo.
    - `SyncCommits(ctx context.Context, since time.Time) error` scans commits since given time, parses and stores new ones.
    - Track last synced commit hash in `daemon_state` to avoid reprocessing.

    **Commit parsing (internal/gitint/commits.go):**
    - `ParseCommits(iter object.CommitIter, store *store.Store) error` iterates commits.
    - For each commit:
      - Extract hash, author name/email, message, timestamp
      - Call `DetectCoAuthor(message string) (bool, string)` -- parse `Co-Authored-By: name <email>` trailer lines. Handle variations: `Co-authored-by`, `co-authored-by` (case insensitive). Return whether tag exists and the coauthor name.
      - Compute diff against parent commit(s): for each changed file, record change type (add/modify/delete/rename), additions count, deletions count, old path (for renames).
      - Handle merge commits (multiple parents): diff against first parent only (standard merge diff behavior).
      - Handle initial commit (no parent): all files are additions.
      - Store in `git_commits` and `git_diffs` tables.
    - For renamed files (GITI-02): go-git's diff provides rename detection. Store both old_path and new file_path in `git_diffs`.
    - For squash merges (GITI-02): detected by large commit touching many files with Co-Authored-By tag. No special handling needed in data layer -- the intelligence layer (Phase 2) will interpret.

    **Blame (internal/gitint/blame.go):**
    - `BlameFile(repo *git.Repository, filePath string) ([]BlameLine, error)` runs git blame on a file.
    - `BlameLine` struct: LineNumber, CommitHash, Author, ContentHash
    - Store results in `git_blame_lines` table. Use content hash to detect when blame data is stale (file changed).
    - Blame is expensive -- don't run on every commit. Run on demand or periodically (configurable, default: on each new commit for changed files only).
    - Handle file not found (deleted files) gracefully.

    **Store integration:**
    - Add `InsertGitCommit(commit GitCommit) error` and `InsertGitDiff(diff GitDiff) error` to store.
    - Add `InsertBlameLine(line BlameLine) error` or batch `InsertBlameLines(lines []BlameLine) error`.
    - Add `CountGitCommits() (int64, error)` for status reporting.
    - Add `GetLastSyncedCommit() (string, error)` and `SetLastSyncedCommit(hash string) error` using daemon_state.

    **Daemon integration:**
    - On startup: open git repo for watched project path, run initial SyncCommits (since last synced or last 30 days for first run).
    - Periodic sync: every 30 seconds, check for new commits and sync (lightweight -- just checks HEAD against last synced).
    - Blame: run for files changed in new commits.
    - On shutdown: no special cleanup needed (all data already in store).

    **Dependency:** `github.com/go-git/go-git/v5`

    **Key decision (from STATE.md):** Git is SECONDARY attribution source (GITI-04). Daemon-captured data (file events + session events) is primary. Git data enriches and validates, but doesn't override. This means: store git data, but don't make decisions about authorship here -- that's Phase 2's job.
  </action>
  <verify>
    `go build ./...` compiles.
    Initialize a test git repo with commits (some with Co-Authored-By tags).
    Start daemon pointed at test repo -- verify commits appear in `git_commits` table with correct coauthor detection.
    Make a new commit -- within 30 seconds, verify it appears in store.
    Check `git_diffs` table shows per-file changes with correct addition/deletion counts.
    Rename a file, commit -- verify `git_diffs` has old_path and new file_path.
    `go test ./internal/gitint/ -v` -- parser tests pass for Co-Authored-By detection (case variations, multiple trailers) and diff parsing.
  </verify>
  <done>
    Git commits with metadata, diffs, and Co-Authored-By tags are parsed and stored. Blame data is available for changed files. Renamed files are tracked. Git data is stored as secondary attribution source. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test ./internal/sessionparser/ -v -race` -- all tests pass
3. `go test ./internal/gitint/ -v -race` -- all tests pass
4. Manual: daemon discovers and tails Claude Code session files, new Write events appear in session_events
5. Manual: new session file creation is detected (session rotation)
6. Manual: git commits with Co-Authored-By are parsed, coauthor detected
7. Manual: renamed files show old_path in git_diffs
8. `./whowroteit status` shows non-zero counts for session_events and git_commits
9. Restart daemon -- verify it resumes tailing from last offset (no duplicate events)
</verification>

<success_criteria>
- Claude Code session files discovered and tailed (CCSP-01)
- Write tool_use events extracted with file path and content (CCSP-02)
- Session rotation detected (CCSP-03)
- Parser behind SessionProvider abstraction (CCSP-04)
- Git commits, diffs, blame parsed and stored (GITI-01)
- Rebases, squash merges, renamed files handled (GITI-02)
- Co-Authored-By tags detected (GITI-03)
- Git stored as secondary source (GITI-04)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-pipeline/01-03-SUMMARY.md`
</output>
