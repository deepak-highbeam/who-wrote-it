---
phase: 01-data-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - cmd/whowroteit/main.go
  - internal/daemon/daemon.go
  - internal/daemon/signals.go
  - internal/store/sqlite.go
  - internal/store/schema.go
  - internal/store/migrations.go
  - internal/ipc/server.go
  - internal/ipc/client.go
  - internal/ipc/protocol.go
  - internal/config/config.go
autonomous: true

must_haves:
  truths:
    - "Daemon starts as background process and stays running with <1% CPU idle"
    - "Daemon shuts down cleanly on SIGTERM/SIGINT with no goroutine leaks"
    - "SQLite database is created in WAL mode with all required tables"
    - "CLI client can query daemon status over Unix domain socket and get a response"
    - "Stale socket file from prior crash is cleaned up on startup"
  artifacts:
    - path: "cmd/whowroteit/main.go"
      provides: "CLI entry point with start/stop/status subcommands"
      contains: "cobra.Command"
    - path: "internal/daemon/daemon.go"
      provides: "Daemon lifecycle management"
      exports: ["Daemon", "Start", "Stop"]
    - path: "internal/store/sqlite.go"
      provides: "SQLite connection with WAL mode"
      exports: ["Store", "New", "Close"]
    - path: "internal/store/schema.go"
      provides: "Table definitions for all data types"
      contains: "CREATE TABLE"
    - path: "internal/ipc/server.go"
      provides: "Unix domain socket server"
      exports: ["Server", "Listen"]
    - path: "internal/ipc/client.go"
      provides: "Unix domain socket client for CLI"
      exports: ["Client", "Status"]
  key_links:
    - from: "cmd/whowroteit/main.go"
      to: "internal/daemon/daemon.go"
      via: "start subcommand calls daemon.Start()"
      pattern: "daemon\\.Start"
    - from: "internal/daemon/daemon.go"
      to: "internal/store/sqlite.go"
      via: "daemon opens store on startup"
      pattern: "store\\.New"
    - from: "internal/daemon/daemon.go"
      to: "internal/ipc/server.go"
      via: "daemon starts IPC server"
      pattern: "ipc\\..*Listen"
    - from: "cmd/whowroteit/main.go"
      to: "internal/ipc/client.go"
      via: "status subcommand uses IPC client"
      pattern: "client\\.Status"
---

<objective>
Build the daemon foundation: Go module, process lifecycle with signal handling, SQLite store with schema for all Phase 1 data types, and Unix domain socket IPC for CLI communication.

Purpose: This is the skeleton everything else plugs into. Without a running daemon, open store, and working IPC, no subsystem can function.
Output: A daemon that starts, persists, responds to status queries, and shuts down cleanly.
</objective>

<execution_context>
@/Users/deepakbhimaraju/.claude/get-shit-done/workflows/execute-plan.md
@/Users/deepakbhimaraju/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Go module, daemon lifecycle, and SQLite store</name>
  <files>
    go.mod
    cmd/whowroteit/main.go
    internal/daemon/daemon.go
    internal/daemon/signals.go
    internal/store/sqlite.go
    internal/store/schema.go
    internal/store/migrations.go
    internal/config/config.go
  </files>
  <action>
    Initialize Go module as `github.com/anthropic/who-wrote-it` (or appropriate org).

    **Config (internal/config/config.go):**
    - Struct holding: DataDir (default ~/.whowroteit), SocketPath, DBPath, WatchPaths []string, IgnorePatterns []string
    - Load from config file (TOML or JSON) with sensible defaults
    - DataDir is created if missing

    **SQLite Store (internal/store/):**
    - `sqlite.go`: Open SQLite with WAL mode (`_journal_mode=WAL`), busy timeout 5s. Use `modernc.org/sqlite` (pure Go, no CGO). Export `Store` struct with `New(dbPath string)` and `Close()`.
    - `schema.go`: Define CREATE TABLE statements for:
      - `file_events` (id, project_path, file_path, event_type, timestamp, checksum, debounce_group)
      - `session_events` (id, session_id, event_type, tool_name, file_path, content_hash, timestamp, raw_json)
      - `git_commits` (id, hash, author, message, timestamp, has_coauthor_tag, coauthor_name)
      - `git_diffs` (id, commit_id FK, file_path, old_path, change_type, additions, deletions)
      - `git_blame_lines` (id, file_path, line_number, commit_hash, author, content_hash, last_updated)
      - `daemon_state` (key, value, updated_at) for metadata like last processed positions
    - `migrations.go`: Simple version-based migration runner. Store schema version in `daemon_state`. Run all pending migrations on startup. No third-party migration library needed.

    **Daemon (internal/daemon/):**
    - `daemon.go`: `Daemon` struct holding store, config, IPC server, and a `context.Context` with cancel for coordinated shutdown. `Start()` method: open store, run migrations, start IPC server, block on context. `Stop()` method: cancel context, close store, remove socket file. Export a `Running() bool` method.
    - `signals.go`: Register SIGTERM and SIGINT handlers that call `Stop()`. Use `signal.NotifyContext` for clean integration with the daemon's context.

    **CLI entry point (cmd/whowroteit/main.go):**
    - Use `cobra` for CLI framework. Three subcommands:
      - `start`: Creates daemon, calls Start(). If socket file already exists and daemon responds to ping, print "already running" and exit. If socket file exists but no response (stale), remove it and start.
      - `stop`: Connect to socket, send stop command, wait for confirmation.
      - `status`: Connect to socket, request status, print daemon uptime and data stats.
    - `start --foreground` flag for debugging (don't daemonize, log to stdout).

    **Dependencies:** `github.com/spf13/cobra`, `modernc.org/sqlite`

    **Important:** No CGO. Pure Go only. This must cross-compile cleanly.
  </action>
  <verify>
    `go build ./cmd/whowroteit` compiles without errors.
    `./whowroteit start --foreground` starts daemon, creates SQLite DB in WAL mode (verify with `sqlite3 ~/.whowroteit/whowroteit.db "PRAGMA journal_mode"` returning `wal`), and all tables exist (verify with `.tables`).
    Send SIGTERM -- daemon exits cleanly (exit code 0), socket file is removed.
  </verify>
  <done>
    Daemon binary compiles, starts in foreground mode, creates SQLite database with all 6 tables in WAL mode, handles SIGTERM/SIGINT gracefully, and cleans up socket file on exit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unix domain socket IPC server and client</name>
  <files>
    internal/ipc/server.go
    internal/ipc/client.go
    internal/ipc/protocol.go
  </files>
  <action>
    **Protocol (internal/ipc/protocol.go):**
    - Simple JSON-over-Unix-socket protocol. Each message is a JSON object followed by newline.
    - Request: `{"command": "status|stop|ping", "args": {}}`
    - Response: `{"ok": true, "data": {...}}` or `{"ok": false, "error": "message"}`
    - Define Go structs: `Request`, `Response`, `StatusData` (uptime, db_size_bytes, file_events_count, session_events_count, git_commits_count, watched_paths []).

    **Server (internal/ipc/server.go):**
    - `Server` struct with reference to store and daemon.
    - `Listen(socketPath string, ctx context.Context)` starts accepting connections. Each connection handled in a goroutine.
    - Handler dispatches on command: `ping` returns ok, `status` queries store for counts and returns StatusData, `stop` triggers daemon shutdown.
    - Server stops accepting when context is cancelled. Existing connections drain with 5s timeout.
    - Socket file permissions set to 0600 (owner only).

    **Client (internal/ipc/client.go):**
    - `Client` struct with socket path.
    - `Ping() error` -- tests if daemon is alive.
    - `Status() (*StatusData, error)` -- returns daemon status.
    - `Stop() error` -- requests shutdown.
    - All methods: dial Unix socket, send JSON request, read JSON response, close connection. Timeout of 5s on all operations.

    Wire the IPC server into daemon.Start() (start listening after store is open) and daemon.Stop() (server stops before store closes). Wire the CLI `status` and `stop` subcommands to use the IPC client.
  </action>
  <verify>
    Start daemon in foreground: `./whowroteit start --foreground &`
    Run `./whowroteit status` -- prints daemon uptime and data stats (all zeros initially).
    Run `./whowroteit ping` (or status) -- confirms daemon is alive.
    Run `./whowroteit stop` -- daemon exits cleanly.
    Verify socket file is removed after stop.
    Start daemon again -- no "address already in use" error.
  </verify>
  <done>
    CLI status command returns daemon uptime and data collection counts over Unix socket. Stop command triggers clean shutdown. Stale socket detection works (start after crash succeeds).
  </done>
</task>

</tasks>

<verification>
1. `go build ./cmd/whowroteit` succeeds with no errors
2. `go vet ./...` reports no issues
3. Start daemon: `./whowroteit start --foreground &`
4. Query status: `./whowroteit status` returns JSON with uptime and zero counts
5. Stop daemon: `./whowroteit stop` exits cleanly (exit 0)
6. Verify no socket file remains: `ls /tmp/whowroteit.sock` (or configured path) fails
7. Restart daemon to verify stale socket handling
8. Check SQLite: `sqlite3 ~/.whowroteit/whowroteit.db ".tables"` shows all 6 tables
9. Check WAL: `sqlite3 ~/.whowroteit/whowroteit.db "PRAGMA journal_mode"` returns `wal`
</verification>

<success_criteria>
- Daemon starts, runs continuously with negligible CPU, and stops cleanly on signal (DAEM-01, DAEM-03)
- SQLite database created in WAL mode with all required tables (DAEM-04)
- CLI communicates with daemon over Unix domain socket for status and stop (DAEM-02)
- No CGO dependencies -- pure Go build
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-pipeline/01-01-SUMMARY.md`
</output>
