---
phase: 01-data-pipeline
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/daemon/daemon.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Claude Code session Write events are discovered, tailed, and parsed into structured records in the store as the developer uses Claude Code"
    - "Git commits, diffs, blame data, and Co-Authored-By tags are parsed and stored, including correct handling of rebases, squash merges, and renamed files"
  artifacts:
    - path: "internal/daemon/daemon.go"
      provides: "Daemon Start() wires sessionparser and gitint subsystems"
      contains: "sessionparser"
    - path: "internal/daemon/daemon.go"
      provides: "Daemon Start() initializes git repository and periodic sync"
      contains: "gitint"
  key_links:
    - from: "internal/daemon/daemon.go"
      to: "internal/sessionparser/parser.go"
      via: "import and Discover/WatchForNew/Tail calls in Start()"
      pattern: "sessionparser\\.NewClaudeCodeParser"
    - from: "internal/daemon/daemon.go"
      to: "internal/sessionparser/tailer.go"
      via: "goroutine per discovered session file calling Tail then ParseLine"
      pattern: "NewTailer"
    - from: "internal/daemon/daemon.go"
      to: "internal/store/sqlite.go"
      via: "InsertSessionEvent called for each parsed session event"
      pattern: "InsertSessionEvent"
    - from: "internal/daemon/daemon.go"
      to: "internal/gitint/repository.go"
      via: "gitint.Open and periodic SyncCommits goroutine"
      pattern: "gitint\\.Open"
    - from: "internal/daemon/daemon.go"
      to: "internal/store/sqlite.go"
      via: "Git commits/diffs/blame flow through Repository.SyncCommits to store"
      pattern: "SyncCommits"
---

<objective>
Wire the session parser and git integration subsystems into the daemon's Start() lifecycle so that all three input signals (file events, session events, git data) flow through the daemon into the SQLite store.

Purpose: Phase 1 verification found that sessionparser and gitint packages are complete and tested but never called by the daemon. This gap closure plan wires them in, closing the "built but not wired" pattern.

Output: Modified `internal/daemon/daemon.go` with session discovery/tailing goroutines and periodic git sync goroutine, plus clean shutdown of both subsystems.
</objective>

<execution_context>
@/Users/deepakbhimaraju/.claude/get-shit-done/workflows/execute-plan.md
@/Users/deepakbhimaraju/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-pipeline/01-VERIFICATION.md

# Source files to wire into daemon
@internal/daemon/daemon.go
@internal/sessionparser/provider.go
@internal/sessionparser/parser.go
@internal/sessionparser/tailer.go
@internal/sessionparser/discovery.go
@internal/gitint/repository.go
@internal/gitint/blame.go
@internal/store/sqlite.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire session parser and git integration into daemon lifecycle</name>
  <files>internal/daemon/daemon.go</files>
  <action>
Modify internal/daemon/daemon.go to wire both orphaned subsystems into the daemon Start() and shutdown() methods. All changes are in this ONE file.

**Imports to add:**
- `"github.com/anthropic/who-wrote-it/internal/sessionparser"`
- `"github.com/anthropic/who-wrote-it/internal/gitint"`
- `"strconv"` (for offset persistence)

**Struct fields to add to Daemon:**
- `sessionParser *sessionparser.ClaudeCodeParser` -- the session parser instance
- `gitRepo       *gitint.Repository`              -- the git repository wrapper
- `sessionCancel context.CancelFunc`              -- separate cancel for session goroutines
- `gitCancel     context.CancelFunc`              -- separate cancel for git goroutine

**In Start(), AFTER the watcher block (line ~102), add two blocks:**

**Block 1: Session parser integration**
1. Create a ClaudeCodeParser: `d.sessionParser = sessionparser.NewClaudeCodeParser("", 0)` (empty string = default ~/.claude/projects/, 0 = default 24h maxAge)
2. Call `d.sessionParser.Discover(d.ctx)` to find existing session files
3. Log the number of discovered sessions
4. Create a child context for session goroutines: `sessionCtx, sessionCancel := context.WithCancel(d.ctx)` and store `d.sessionCancel = sessionCancel`
5. For each discovered session file, start a tailer goroutine (call helper method `d.startSessionTailer(sessionCtx, sf)`)
6. Start a `WatchForNew` goroutine that listens for new session files on a channel and starts a tailer for each one:
   ```go
   newSessions := make(chan sessionparser.SessionFile, 10)
   go func() {
       if err := d.sessionParser.WatchForNew(sessionCtx, newSessions); err != nil {
           log.Printf("session watcher error: %v", err)
       }
   }()
   go func() {
       for {
           select {
           case <-sessionCtx.Done():
               return
           case sf := <-newSessions:
               d.startSessionTailer(sessionCtx, sf)
           }
       }
   }()
   ```

**Add helper method `startSessionTailer`:**
```go
func (d *Daemon) startSessionTailer(ctx context.Context, sf sessionparser.SessionFile) {
    // Restore offset from daemon_state (key: "tailer_offset:" + sf.Path)
    offsetKey := "tailer_offset:" + sf.Path
    offsetStr, _ := d.store.GetDaemonState(offsetKey)
    var offset int64
    if offsetStr != "" {
        offset, _ = strconv.ParseInt(offsetStr, 10, 64)
    }

    tailer := sessionparser.NewTailer(sf.Path, offset, 0)
    lines := make(chan []byte, 100)

    go func() {
        finalOffset, err := tailer.Tail(ctx, lines)
        if err != nil {
            log.Printf("session tailer %s error: %v", sf.Path, err)
        }
        // Persist final offset for resume.
        _ = d.store.SetDaemonState(offsetKey, strconv.FormatInt(finalOffset, 10))
    }()

    go func() {
        for {
            select {
            case <-ctx.Done():
                return
            case line := <-lines:
                event, err := d.sessionParser.ParseLine(line)
                if err != nil {
                    log.Printf("session parse error: %v", err)
                    continue
                }
                if event == nil {
                    continue
                }
                event.SessionID = sf.SessionID
                if err := d.store.InsertSessionEvent(
                    event.SessionID, event.EventType, event.ToolName,
                    event.FilePath, event.ContentHash, event.Timestamp, event.RawJSON,
                ); err != nil {
                    log.Printf("session store error: %v", err)
                }
            }
        }
    }()

    log.Printf("tailing session: %s", sf.Path)
}
```

**Block 2: Git integration**
1. Only wire git if WatchPaths are configured (use first watch path as repo path): `if len(d.cfg.WatchPaths) > 0 {`
2. Open git repo: `repo, err := gitint.Open(d.cfg.WatchPaths[0], d.store)` -- if err (not a git repo), log warning and skip (non-fatal)
3. Store on daemon: `d.gitRepo = repo`
4. Create child context: `gitCtx, gitCancel := context.WithCancel(d.ctx)` and store `d.gitCancel = gitCancel`
5. Run initial sync: `repo.SyncCommits(gitCtx, time.Now().Add(-gitint.DefaultLookback()))`
6. Start periodic sync goroutine:
   ```go
   go func() {
       ticker := time.NewTicker(gitint.SyncInterval())
       defer ticker.Stop()
       for {
           select {
           case <-gitCtx.Done():
               return
           case <-ticker.C:
               since := time.Now().Add(-gitint.DefaultLookback())
               if err := repo.SyncCommits(gitCtx, since); err != nil {
                   log.Printf("git sync error: %v", err)
               }
           }
       }
   }()
   ```

**In shutdown(), BEFORE the watcher stop (line ~134), add:**
1. Cancel session goroutines: `if d.sessionCancel != nil { d.sessionCancel() }`
2. Cancel git goroutine: `if d.gitCancel != nil { d.gitCancel() }`

This ensures session tailers flush their final offsets and git sync stops before the store closes.

**Important constraints:**
- Do NOT change any existing working code (watcher, IPC, store wiring). Only ADD new blocks.
- Do NOT modify any other files. The sessionparser and gitint packages are complete.
- Use `log.Printf` consistently with existing daemon logging style.
- Session and git failures are non-fatal (log and continue). The daemon must not crash if ~/.claude/projects/ does not exist or if the watch path is not a git repo.
  </action>
  <verify>
Run these commands from the project root:

1. `go build ./...` -- must compile with zero errors
2. `go vet ./...` -- must pass with zero warnings
3. `go test -race ./...` -- all existing tests must still pass (watcher, sessionparser, gitint tests)
4. Verify imports: `grep -c 'sessionparser' internal/daemon/daemon.go` should return >= 1
5. Verify imports: `grep -c 'gitint' internal/daemon/daemon.go` should return >= 1
6. Verify wiring: `grep -c 'Discover' internal/daemon/daemon.go` should return >= 1
7. Verify wiring: `grep -c 'SyncCommits' internal/daemon/daemon.go` should return >= 1
8. Verify wiring: `grep -c 'InsertSessionEvent' internal/daemon/daemon.go` should return >= 1
9. Verify wiring: `grep -c 'startSessionTailer' internal/daemon/daemon.go` should return >= 2 (definition + calls)
  </verify>
  <done>
daemon.go imports sessionparser and gitint packages. Start() calls Discover(), starts WatchForNew(), launches tailer goroutines, opens git repo, runs initial SyncCommits(), starts periodic sync ticker. shutdown() cancels session and git contexts before stopping watcher and closing store. All existing tests pass. Code compiles cleanly.
  </done>
</task>

</tasks>

<verification>
After task completion, verify the two failed truths from 01-VERIFICATION.md are now closable:

1. **Session parser wired:** `daemon.go` imports `sessionparser`, calls `Discover()`, starts `WatchForNew()` goroutine, starts tailer goroutines that call `ParseLine()` and `InsertSessionEvent()`. The data path from session file -> parser -> store is complete.

2. **Git integration wired:** `daemon.go` imports `gitint`, calls `gitint.Open()`, runs initial `SyncCommits()`, starts periodic sync goroutine. The data path from git repo -> commits/diffs/blame -> store is complete.

3. **No regressions:** All existing tests pass (watcher debounce/filter, sessionparser parsing/discovery/tailer, gitint coauthor/sync/blame).

4. **Clean shutdown:** Session and git goroutines cancelled BEFORE watcher stops and store closes.
</verification>

<success_criteria>
- `go build ./...` succeeds
- `go test -race ./...` passes all tests
- `grep 'sessionparser' internal/daemon/daemon.go` shows import and usage
- `grep 'gitint' internal/daemon/daemon.go` shows import and usage
- daemon.go Start() has session discovery, tailing, git open, and periodic sync
- daemon.go shutdown() cancels session and git contexts
- Phase 1 truths #3 and #4 are now achievable (data can flow)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-pipeline/01-04-SUMMARY.md`
</output>
