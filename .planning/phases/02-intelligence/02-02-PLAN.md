---
phase: 02-intelligence
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/worktype/classifier.go
  - internal/worktype/classifier_test.go
  - internal/worktype/patterns.go
  - internal/metrics/calculator.go
  - internal/metrics/calculator_test.go
  - internal/store/sqlite.go
  - internal/store/schema.go
autonomous: true

must_haves:
  truths:
    - "Each file change is classified into one of six work types: architecture, core_logic, boilerplate, bug_fix, edge_case, test_scaffolding"
    - "Test files are classified as test_scaffolding based on file path patterns"
    - "Interface and struct definitions are classified as architecture"
    - "Meaningful AI % weights architecture and core logic higher than boilerplate"
    - "Per-file and per-project AI percentages are computed"
    - "User can override a work-type classification for a specific file/commit"
    - "Overrides apply to the specific file/commit only, no propagation"
  artifacts:
    - path: "internal/worktype/classifier.go"
      provides: "Heuristic work-type classifier"
      exports: ["WorkType", "ClassifyFile", "Classifier"]
    - path: "internal/worktype/patterns.go"
      provides: "File path and code pattern rules for work-type detection"
      exports: ["patterns"]
    - path: "internal/metrics/calculator.go"
      provides: "Meaningful AI percentage calculator with weighted work types"
      exports: ["Calculator", "FileMetrics", "ProjectMetrics", "ComputeFileMetrics", "ComputeProjectMetrics"]
    - path: "internal/store/schema.go"
      provides: "Schema migration v3 with work_type_overrides table and work_type column on attributions"
      contains: "CREATE TABLE IF NOT EXISTS work_type_overrides"
    - path: "internal/store/sqlite.go"
      provides: "Store methods for work-type overrides and metrics queries"
      exports: ["InsertWorkTypeOverride", "QueryWorkTypeOverride", "QueryAttributionsWithWorkType"]
  key_links:
    - from: "internal/worktype/classifier.go"
      to: "internal/store/sqlite.go"
      via: "Reads git_diffs for change patterns, checks overrides"
      pattern: "QueryWorkTypeOverride"
    - from: "internal/metrics/calculator.go"
      to: "internal/store/sqlite.go"
      via: "Reads attributions with work types for weighted calculation"
      pattern: "QueryAttributionsWithWorkType|QueryAttributionsByFile"
    - from: "internal/metrics/calculator.go"
      to: "internal/worktype/classifier.go"
      via: "Uses WorkType constants for weight lookup"
      pattern: "worktype\\.WorkType"
---

<objective>
Build the heuristic work-type classifier and meaningful AI percentage metric. The work-type classifier labels each file change as architecture, core logic, boilerplate, bug fix, edge case handling, or test scaffolding using file paths and code patterns. The metric calculator computes a weighted "meaningful AI %" that values architecture and core logic higher than boilerplate, computed per-file and per-project. Users can override misclassifications on a per-file/commit basis.

Purpose: Raw AI percentages are misleading -- "AI wrote 80% of lines" means nothing if those lines are import statements. This plan makes the metric meaningful by weighting what matters.
Output: `internal/worktype/` and `internal/metrics/` packages with tests, work_type_overrides table, store methods for overrides and metrics queries.
</objective>

<execution_context>
@/Users/deepakbhimaraju/.claude/get-shit-done/workflows/execute-plan.md
@/Users/deepakbhimaraju/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligence/02-CONTEXT.md
@.planning/phases/02-intelligence/02-01-SUMMARY.md

## Key Context from Plan 02-01

**AuthorshipLevel constants** (from `internal/authorship/classifier.go`):
- `FullyAI`, `AIFirstHumanRevised`, `HumanFirstAIRevised`, `AISuggestedHumanWritten`, `FullyHuman`

**Attribution struct** (from `internal/authorship/classifier.go`):
- FilePath, ProjectPath, FileEventID, SessionEventID, Level (AuthorshipLevel), Confidence, Uncertain, FirstAuthor, CorrelationWindowMs, Timestamp

**attributions table** (from schema migration v2):
- id, file_path, project_path, file_event_id, session_event_id, authorship_level, confidence, uncertain, first_author, correlation_window_ms, timestamp, created_at

**Locked decisions from CONTEXT.md:**
- Three weighting tiers: High (architecture, core logic), Medium (bug fix, edge case handling), Low (boilerplate, test scaffolding)
- File + pattern based detection (file paths, code patterns, change size)
- Per-file granularity: each file gets one work-type label
- One-time overrides only: specific file/commit, no propagation
- Heuristic rules, not LLM
</context>

<tasks>

<task type="auto">
  <name>Task 1: Work-type classifier and patterns, schema migration, store methods</name>
  <files>
    internal/worktype/classifier.go
    internal/worktype/patterns.go
    internal/store/schema.go
    internal/store/sqlite.go
  </files>
  <action>
**Step 1: Work-type constants and patterns** (`internal/worktype/patterns.go`)

Define WorkType:
```go
type WorkType string
const (
    Architecture    WorkType = "architecture"
    CoreLogic       WorkType = "core_logic"
    Boilerplate     WorkType = "boilerplate"
    BugFix          WorkType = "bug_fix"
    EdgeCase        WorkType = "edge_case"
    TestScaffolding WorkType = "test_scaffolding"
)
```

Define weight tiers:
```go
type WeightTier string
const (
    TierHigh   WeightTier = "high"
    TierMedium WeightTier = "medium"
    TierLow    WeightTier = "low"
)

var WorkTypeWeights = map[WorkType]float64{
    Architecture:    3.0,  // High tier
    CoreLogic:       3.0,  // High tier
    BugFix:          2.0,  // Medium tier
    EdgeCase:        2.0,  // Medium tier
    Boilerplate:     1.0,  // Low tier
    TestScaffolding: 1.0,  // Low tier
}

var WorkTypeTier = map[WorkType]WeightTier{
    Architecture:    TierHigh,
    CoreLogic:       TierHigh,
    BugFix:          TierMedium,
    EdgeCase:        TierMedium,
    Boilerplate:     TierLow,
    TestScaffolding: TierLow,
}
```

Define heuristic pattern rules as structs:
```go
type PatternRule struct {
    WorkType  WorkType
    FileGlobs []string   // Match against file path
    Keywords  []string   // Match against file content/diff content
    Priority  int        // Higher priority wins conflicts
}
```

Default rules (ordered by priority):
1. **Test scaffolding** (priority 10): Files matching `*_test.go`, `*_test.ts`, `*_test.py`, `test_*.py`, `*.test.js`, `*.test.ts`, `*.spec.js`, `*.spec.ts`, paths containing `/test/`, `/tests/`, `/__tests__/`
2. **Boilerplate** (priority 20): Files matching `go.mod`, `go.sum`, `package.json`, `package-lock.json`, `*.lock`, `Makefile`, `Dockerfile`, `*.yml`, `*.yaml`, `*.toml` (config files). Also `.gitignore`, `LICENSE`, files with only import/package statements
3. **Architecture** (priority 40): Files containing `interface `, `type.*struct`, `trait `, `abstract class`, `protocol ` keywords. Also files in paths like `*/models/*`, `*/schema/*`, `*/types/*`, `*/interfaces/*`
4. **Edge case** (priority 30): Files/diffs with keywords like `if err`, `catch`, `except`, `default:`, `case .*:`, `fallback`, `|| ""`, `?? `, `// edge case`, `// handle`, error-handling-heavy patterns
5. **Bug fix** (priority 35): Detected via git commit message keywords: `fix`, `bug`, `patch`, `hotfix`, `resolve`, `issue`. This is a secondary signal (commit-level, not file-level), used when the file itself doesn't match other patterns
6. **Core logic** (priority 50): Default fallback. If a file doesn't match any of the above patterns, it's core logic. This is intentional -- core business logic lives in regular `.go`, `.ts`, `.py` files that don't match special patterns

**Step 2: Work-type classifier** (`internal/worktype/classifier.go`)

Create `Classifier` struct with `rules []PatternRule` (loaded from defaults, extensible).

Method `ClassifyFile(filePath string, diffContent string, commitMessage string) WorkType`:
1. Check for override in store first (via OverrideReader interface)
2. Run pattern rules in priority order (highest priority first)
3. File glob match: check if filePath matches any glob
4. Keyword match: check if diffContent contains any keyword
5. Commit message match (for bug_fix): check commit message
6. First matching rule at highest priority wins
7. Default: CoreLogic

Interface for override checking:
```go
type OverrideReader interface {
    QueryWorkTypeOverride(filePath string, commitHash string) (WorkType, bool, error)
}
```

**Step 3: Schema migration v3** (`internal/store/schema.go`)

Increment `schemaVersion` to 3. Add migration 3:

```sql
-- Work-type overrides from user corrections.
CREATE TABLE IF NOT EXISTS work_type_overrides (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    file_path   TEXT NOT NULL,
    commit_hash TEXT NOT NULL DEFAULT '',
    work_type   TEXT NOT NULL,
    created_at  TEXT NOT NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_work_type_override_file_commit
    ON work_type_overrides(file_path, commit_hash);

-- Add work_type column to attributions table.
ALTER TABLE attributions ADD COLUMN work_type TEXT NOT NULL DEFAULT '';
```

**Step 4: Store methods** (`internal/store/sqlite.go`)

Add methods:
1. `InsertWorkTypeOverride(filePath, commitHash string, workType string) error` -- INSERT OR REPLACE INTO work_type_overrides
2. `QueryWorkTypeOverride(filePath, commitHash string) (string, bool, error)` -- SELECT work_type FROM work_type_overrides WHERE file_path = ? AND commit_hash = ?. Returns (workType, found, error).
3. `UpdateAttributionWorkType(attrID int64, workType string) error` -- UPDATE attributions SET work_type = ? WHERE id = ?
4. `QueryAttributionsWithWorkType(projectPath string) ([]AttributionWithWorkType, error)` -- SELECT from attributions WHERE project_path = ? AND work_type != '' ORDER BY timestamp. Returns struct with attribution fields plus work_type.
5. `QueryAttributionsByFileWithWorkType(filePath string) ([]AttributionWithWorkType, error)` -- Same but filtered by file_path.

Define `AttributionWithWorkType` struct extending AttributionRecord with WorkType field.
  </action>
  <verify>
    Run `go build ./...` -- zero errors.
    Run `go vet ./...` -- zero warnings.
    Verify schema version is 3 in schema.go.
    Verify work_type_overrides table DDL in migrations map.
    Verify ALTER TABLE adds work_type to attributions.
    Verify 6 work type constants defined.
    Verify 3 weight tiers with correct mappings.
    Verify ClassifyFile method exists with override check, pattern match, and default fallback.
  </verify>
  <done>
    Work-type classifier with 6 categories and heuristic pattern rules. Three weight tiers (high/medium/low). Schema v3 adds work_type_overrides table and work_type column. Store methods for overrides and work-type queries. Override reader interface for DI. Code compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Metrics calculator, tests for work-type and metrics</name>
  <files>
    internal/metrics/calculator.go
    internal/metrics/calculator_test.go
    internal/worktype/classifier_test.go
  </files>
  <action>
**Step 1: Metrics calculator** (`internal/metrics/calculator.go`)

Define result types:
```go
type FileMetrics struct {
    FilePath          string
    WorkType          string
    AuthorshipCounts  map[string]int  // authorship_level -> count
    TotalEvents       int
    AIEventCount      int             // fully_ai + ai_first_human_revised
    MeaningfulAIPct   float64         // weighted AI percentage
    RawAIPct          float64         // unweighted AI percentage (for comparison)
}

type ProjectMetrics struct {
    ProjectPath       string
    TotalFiles        int
    FileMetrics       []FileMetrics
    MeaningfulAIPct   float64         // weighted aggregate
    RawAIPct          float64         // unweighted aggregate
    ByWorkType        map[string]WorkTypeBreakdown
    ByAuthorship      map[string]int  // authorship_level -> total count
}

type WorkTypeBreakdown struct {
    WorkType     string
    Tier         string
    Weight       float64
    FileCount    int
    AIEventCount int
    TotalEvents  int
    AIPct        float64
}
```

Create `Calculator` struct.

Method `ComputeFileMetrics(filePath string, attributions []AttributionWithWorkType) FileMetrics`:
1. Count attributions by authorship level
2. AI events = count of fully_ai + ai_first_human_revised (these represent direct AI authorship)
3. RawAIPct = AIEventCount / TotalEvents * 100
4. MeaningfulAIPct = same as RawAIPct (per-file, no cross-file weighting yet)
5. WorkType from first attribution's work_type (per-file granularity)

Method `ComputeProjectMetrics(projectPath string, allAttributions []AttributionWithWorkType) ProjectMetrics`:
1. Group attributions by file_path
2. Compute FileMetrics for each file
3. For the project-level MeaningfulAIPct:
   - For each file: `weighted_ai = ai_event_count * WorkTypeWeights[work_type]`
   - For each file: `weighted_total = total_events * WorkTypeWeights[work_type]`
   - MeaningfulAIPct = sum(weighted_ai) / sum(weighted_total) * 100
   - This means a file classified as "architecture" with 50% AI has more impact on the project metric than a "boilerplate" file with 50% AI
4. RawAIPct = sum(ai_events) / sum(total_events) * 100 (unweighted, for comparison)
5. ByWorkType: group files by work type, compute per-group metrics
6. ByAuthorship: aggregate authorship level counts across all files

Handle edge cases:
- Zero total events -> 0% (not NaN)
- Files with no work_type set -> treat as core_logic (default)
- Uncertain attributions: still counted (uncertain = low confidence, not "exclude from metrics")

**Step 2: Work-type classifier tests** (`internal/worktype/classifier_test.go`)

Test cases:
1. **Test file -> test_scaffolding**: `internal/store/sqlite_test.go` -> TestScaffolding
2. **Config file -> boilerplate**: `go.mod`, `Dockerfile`, `.gitignore` -> Boilerplate
3. **Interface definition -> architecture**: file with `type Foo interface {` -> Architecture
4. **Struct definition -> architecture**: file with `type Config struct {` -> Architecture
5. **Error handling -> edge_case**: file heavy with `if err != nil` patterns -> EdgeCase
6. **Bug fix commit -> bug_fix**: commit message "fix: resolve nil pointer" -> BugFix
7. **Regular Go file -> core_logic**: `internal/daemon/daemon.go` with normal code -> CoreLogic (default)
8. **Override wins**: Mock override returns Architecture. Regular file would be CoreLogic. Result = Architecture
9. **Priority ordering**: File matches both test (priority 10) and boilerplate (priority 20). Test wins (lower number = checked first... actually higher priority number wins). Define clearly: highest priority number wins.

Wait -- reconsider priority direction. Let's use: highest priority value wins, and we check in descending priority order. Core logic is default fallback, not a rule. So:
- CoreLogic (priority 50) = default, highest numeric but it's the fallback
- Architecture (priority 40)
- BugFix (priority 35)
- EdgeCase (priority 30)
- Boilerplate (priority 20)
- TestScaffolding (priority 10)

Actually, simpler approach: check rules in ORDER. First match wins. Check test first (most specific), then architecture, edge case, bug fix, boilerplate. If nothing matches, default to core_logic. No priority numbers needed -- just ordered rule evaluation.

Update tests:
1. Test file paths -> test_scaffolding (checked first)
2. Config/lock files -> boilerplate
3. Interface/struct patterns -> architecture
4. Error-handling patterns -> edge_case
5. Bug-fix commit message -> bug_fix
6. Default -> core_logic
7. Override takes precedence over all rules
8. Classify returns correct WorkType for each category

**Step 3: Metrics calculator tests** (`internal/metrics/calculator_test.go`)

Test cases:
1. **Single file, all AI**: 5 fully_ai attributions. RawAIPct = 100%, MeaningfulAIPct = 100%
2. **Single file, mixed**: 3 fully_ai + 2 fully_human. RawAIPct = 60%
3. **Project weighted**: File A (architecture, 2 AI / 4 total), File B (boilerplate, 3 AI / 3 total). RawAIPct = (2+3)/(4+3) = 71%. MeaningfulAIPct = (2*3+3*1)/(4*3+3*1) = 9/15 = 60%. Architecture AI drags the weighted metric down because arch has 50% AI.
4. **Zero events -> 0%**: Empty attributions. Both percentages = 0.
5. **WorkType breakdown**: Project with files in 3 different work types. ByWorkType map has 3 entries.
6. **Authorship counts**: Check ByAuthorship aggregation.
7. **File with no work_type -> treated as core_logic**: Verify default handling.
8. **AI events include fully_ai AND ai_first_human_revised**: Both count as AI-authored.

Run all tests with `-race` flag.
  </action>
  <verify>
    Run `go test -race -v ./internal/worktype/...` -- all tests pass.
    Run `go test -race -v ./internal/metrics/...` -- all tests pass.
    Run `go test -race ./...` -- all existing tests still pass.
    Verify at least 7 test functions in classifier_test.go.
    Verify at least 6 test functions in calculator_test.go.
    Verify ComputeFileMetrics and ComputeProjectMetrics produce correct percentages.
  </verify>
  <done>
    Work-type classifier has 7+ tests covering all 6 categories, override precedence, and default fallback. Metrics calculator has 6+ tests covering single file, mixed, weighted project, zero events, breakdown, and AI event inclusion. Weighted meaningful AI % correctly values architecture/core logic 3x over boilerplate. All tests pass with race detector.
  </done>
</task>

</tasks>

<verification>
Run the full verification sequence:
1. `go build ./...` compiles without errors
2. `go vet ./...` passes without warnings
3. `go test -race ./...` -- all tests pass (new + existing)
4. Schema version is 3, migrations create work_type_overrides table and add work_type column
5. At least 13 new tests across worktype and metrics packages
6. Work-type classifier handles all 6 categories with heuristic rules
7. Metrics calculator produces correct weighted percentages
8. Overrides are stored and checked before pattern rules
9. Three weight tiers (3.0, 2.0, 1.0) correctly applied
</verification>

<success_criteria>
- Each file change classifiable into one of 6 work types using heuristic rules
- Test files detected by path pattern (*_test.go, etc.)
- Config/lock files detected as boilerplate
- Interface/struct definitions detected as architecture
- Default fallback is core_logic (most code)
- User overrides stored per file/commit, checked before rules
- Meaningful AI % = weighted sum using 3.0/2.0/1.0 tier weights
- Per-file and per-project metrics computed
- Raw AI % also computed for comparison
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligence/02-02-SUMMARY.md`
</output>
