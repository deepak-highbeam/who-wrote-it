---
phase: 02-intelligence
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - internal/correlation/correlator.go
  - internal/correlation/correlator_test.go
  - internal/authorship/classifier.go
  - internal/authorship/classifier_test.go
  - internal/store/sqlite.go
  - internal/store/schema.go
  - internal/store/migrations.go
autonomous: true

must_haves:
  truths:
    - "File events within 5s of a Claude Write session event are correlated as AI-authored"
    - "File events with no matching session event are classified as fully human"
    - "Closest-in-time session event wins when multiple candidates exist"
    - "Each attribution record carries a five-level authorship label and confidence score"
    - "Ambiguous cases (low confidence) are marked as uncertain rather than guessed"
    - "First-author-wins rule determines spectrum direction for iterative edits"
  artifacts:
    - path: "internal/correlation/correlator.go"
      provides: "Event correlation engine matching file events to session events"
      exports: ["Correlator", "CorrelationResult", "Correlate"]
    - path: "internal/authorship/classifier.go"
      provides: "Five-level authorship spectrum classifier"
      exports: ["Classifier", "AuthorshipLevel", "Attribution", "Classify"]
    - path: "internal/store/schema.go"
      provides: "Schema migration v2 with attributions table"
      contains: "CREATE TABLE IF NOT EXISTS attributions"
    - path: "internal/store/sqlite.go"
      provides: "Store methods for querying events and writing attributions"
      exports: ["QueryFileEventsInWindow", "QuerySessionEventsInWindow", "InsertAttribution"]
  key_links:
    - from: "internal/correlation/correlator.go"
      to: "internal/store/sqlite.go"
      via: "Store queries for file_events and session_events"
      pattern: "QueryFileEventsInWindow|QuerySessionEventsInWindow"
    - from: "internal/authorship/classifier.go"
      to: "internal/correlation/correlator.go"
      via: "CorrelationResult feeds into Classify"
      pattern: "CorrelationResult"
    - from: "internal/store/sqlite.go"
      to: "attributions table"
      via: "InsertAttribution persists classification results"
      pattern: "INSERT INTO attributions"
---

<objective>
Build the event correlation engine and five-level authorship classifier. The correlator matches file system events to Claude Code session events using time-window proximity. The classifier assigns each correlation to the five-level authorship spectrum (fully AI, AI-first/human-revised, human-first/AI-revised, AI-suggested/human-written, fully human) with a confidence score. Ambiguous cases are marked uncertain.

Purpose: This is the core intelligence -- turning raw signals from Phase 1 into meaningful attribution records. Without this, we have data but no insight.
Output: `internal/correlation/` and `internal/authorship/` packages with tests, new attributions table in SQLite, store query/insert methods.
</objective>

<execution_context>
@/Users/deepakbhimaraju/.claude/get-shit-done/workflows/execute-plan.md
@/Users/deepakbhimaraju/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligence/02-CONTEXT.md

## Key Phase 1 Context

**Existing tables (from schema.go):**
- `file_events`: id, project_path, file_path, event_type, timestamp, checksum, debounce_group
- `session_events`: id, session_id, event_type, tool_name, file_path, content_hash, timestamp, raw_json
- `git_commits`: id, hash, author, message, timestamp, has_coauthor_tag, coauthor_name
- `git_diffs`: id, commit_id, file_path, old_path, change_type, additions, deletions
- `git_blame_lines`: id, file_path, line_number, commit_hash, author, content_hash, last_updated
- `daemon_state`: key, value, updated_at

**Timestamps:** All stored as RFC3339Nano strings in UTC.

**SessionEvent type (from provider.go):**
```go
type SessionEvent struct {
    SessionID   string
    EventType   string    // "tool_use"
    ToolName    string    // "Write", "Read", "Bash"
    FilePath    string
    ContentHash string
    Timestamp   time.Time
    RawJSON     string
}
```

**Locked decisions from CONTEXT.md (do NOT revisit):**
- Any human edit to Claude-written code = "AI-first/human-revised" (no threshold)
- First author wins for iterative collaboration
- No tool use = fully human (idle sessions don't taint)
- Tight time windows (seconds) for correlation
- Closest in time wins for multiple matches
- Daemon data is truth, git fills gaps
- Session context match = "AI-suggested/human-written"

**Existing patterns:**
- Store methods on `*Store` struct, direct SQL
- Schema migrations via versioned map in schema.go
- Interface-based DI (packages define their own interfaces for dependencies)
- Per-subsystem packages under `internal/`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store queries, schema migration, correlation engine, and authorship classifier</name>
  <files>
    internal/store/schema.go
    internal/store/migrations.go
    internal/store/sqlite.go
    internal/correlation/correlator.go
    internal/authorship/classifier.go
  </files>
  <action>
**Step 1: Schema migration v2 -- Add attributions table**

In `internal/store/schema.go`, increment `schemaVersion` to 2. Add migration 2 to the `migrations` map:

```sql
CREATE TABLE IF NOT EXISTS attributions (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    file_path       TEXT    NOT NULL,
    project_path    TEXT    NOT NULL,
    file_event_id   INTEGER REFERENCES file_events(id),
    session_event_id INTEGER REFERENCES session_events(id),
    authorship_level TEXT   NOT NULL,  -- 'fully_ai', 'ai_first_human_revised', 'human_first_ai_revised', 'ai_suggested_human_written', 'fully_human'
    confidence       REAL   NOT NULL DEFAULT 1.0,
    uncertain        INTEGER NOT NULL DEFAULT 0,
    first_author     TEXT   NOT NULL DEFAULT '',  -- 'ai' or 'human'
    correlation_window_ms INTEGER NOT NULL DEFAULT 0,
    timestamp        TEXT   NOT NULL,
    created_at       TEXT   NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_attributions_file ON attributions(file_path);
CREATE INDEX IF NOT EXISTS idx_attributions_project ON attributions(project_path);
CREATE INDEX IF NOT EXISTS idx_attributions_level ON attributions(authorship_level);
CREATE INDEX IF NOT EXISTS idx_attributions_timestamp ON attributions(timestamp);
```

**Step 2: Store query and insert methods**

Add to `internal/store/sqlite.go`:

1. `FileEvent` struct: `ID int64, ProjectPath, FilePath, EventType string, Timestamp time.Time`
2. `StoredSessionEvent` struct: `ID int64, SessionID, EventType, ToolName, FilePath, ContentHash string, Timestamp time.Time`
3. `AttributionRecord` struct: `ID int64, FilePath, ProjectPath string, FileEventID, SessionEventID *int64, AuthorshipLevel string, Confidence float64, Uncertain bool, FirstAuthor string, CorrelationWindowMs int, Timestamp time.Time`

4. `QueryFileEventsInWindow(filePath string, start, end time.Time) ([]FileEvent, error)` -- SELECT from file_events WHERE file_path = ? AND timestamp BETWEEN ? AND ? ORDER BY timestamp ASC
5. `QuerySessionEventsInWindow(filePath string, start, end time.Time) ([]StoredSessionEvent, error)` -- SELECT from session_events WHERE file_path = ? AND timestamp BETWEEN ? AND ? ORDER BY timestamp ASC. Also query events where tool_name = 'Write' (the primary correlation signal).
6. `QuerySessionEventsNearTimestamp(timestamp time.Time, windowMs int) ([]StoredSessionEvent, error)` -- SELECT from session_events WHERE tool_name = 'Write' AND ABS(CAST((julianday(timestamp) - julianday(?)) * 86400000 AS INTEGER)) <= ? ORDER BY ABS(CAST((julianday(timestamp) - julianday(?)) * 86400000 AS INTEGER)) ASC. This finds Write events within windowMs of a given timestamp regardless of file path.
7. `InsertAttribution(attr AttributionRecord) (int64, error)` -- INSERT INTO attributions
8. `QueryAttributionsByFile(filePath string) ([]AttributionRecord, error)` -- SELECT from attributions WHERE file_path = ? ORDER BY timestamp ASC
9. `QueryAttributionsByProject(projectPath string) ([]AttributionRecord, error)` -- SELECT from attributions WHERE project_path = ? ORDER BY timestamp ASC

**Step 3: Correlation engine** (`internal/correlation/correlator.go`)

Define types:
```go
type AuthorshipLevel string
const (
    FullyAI                AuthorshipLevel = "fully_ai"
    AIFirstHumanRevised    AuthorshipLevel = "ai_first_human_revised"
    HumanFirstAIRevised    AuthorshipLevel = "human_first_ai_revised"
    AISuggestedHumanWritten AuthorshipLevel = "ai_suggested_human_written"
    FullyHuman             AuthorshipLevel = "fully_human"
)

type CorrelationResult struct {
    FileEvent       FileEvent
    MatchedSession  *StoredSessionEvent  // nil if no match
    TimeDeltaMs     int64                // ms between events, 0 if no match
    MatchType       string               // "exact_file", "time_proximity", "none"
}
```

Create `Correlator` struct with configurable `WindowMs int` (default 5000ms = 5 seconds). The correlator needs a `StoreReader` interface (not importing store directly):

```go
type StoreReader interface {
    QueryFileEventsInWindow(filePath string, start, end time.Time) ([]store.FileEvent, error)
    QuerySessionEventsInWindow(filePath string, start, end time.Time) ([]store.StoredSessionEvent, error)
    QuerySessionEventsNearTimestamp(timestamp time.Time, windowMs int) ([]store.StoredSessionEvent, error)
}
```

Method `CorrelateFileEvent(fe store.FileEvent) (*CorrelationResult, error)`:
1. Define window: `fe.Timestamp - WindowMs` to `fe.Timestamp + WindowMs`
2. Query session events for the SAME file_path in that window
3. If exact file match found: pick closest-in-time. Set MatchType = "exact_file"
4. If no exact match: query ALL Write session events near timestamp. If any found within window: pick closest. Set MatchType = "time_proximity"
5. If still no match: MatchType = "none", MatchedSession = nil

Method `CorrelateAll(projectPath string, since time.Time) ([]CorrelationResult, error)`:
- Query all file events for project since given time
- Correlate each one
- Return results

**Step 4: Authorship classifier** (`internal/authorship/classifier.go`)

Create `Classifier` struct.

Define `Attribution` struct:
```go
type Attribution struct {
    FilePath         string
    ProjectPath      string
    FileEventID      *int64
    SessionEventID   *int64
    Level            AuthorshipLevel
    Confidence       float64
    Uncertain        bool
    FirstAuthor      string  // "ai" or "human"
    CorrelationWindowMs int
    Timestamp        time.Time
}
```

Method `Classify(result CorrelationResult) Attribution`:

Apply the locked decision rules:
1. **No match (MatchType == "none"):** Level = FullyHuman, Confidence = 1.0, FirstAuthor = "human"
2. **Exact file match, time_delta < 2000ms:** Level = FullyAI, Confidence = 0.95, FirstAuthor = "ai" (Claude wrote this file directly via Write tool)
3. **Exact file match, time_delta 2000-5000ms:** Level = AIFirstHumanRevised, Confidence = 0.7, FirstAuthor = "ai" (likely AI wrote, human may have edited)
4. **Time proximity only (different file):** Level = AISuggestedHumanWritten, Confidence = 0.5, FirstAuthor = "human" (AI was active but didn't write this file directly)
5. **Confidence < 0.5:** Mark Uncertain = true

For determining first-author-wins on subsequent edits to the same file:
- Method `ClassifyWithHistory(result CorrelationResult, priorAttribution *Attribution) Attribution`:
  - If priorAttribution exists AND priorAttribution.FirstAuthor == "ai" AND current result has no session match: Level = AIFirstHumanRevised (human is revising AI code)
  - If priorAttribution exists AND priorAttribution.FirstAuthor == "human" AND current result has session match: Level = HumanFirstAIRevised (AI is revising human code)
  - Otherwise: fall through to standard Classify

For git-only attribution (no daemon data, gap fill):
- Method `ClassifyFromGit(hasCoauthorTag bool, coauthorName string) Attribution`:
  - If hasCoauthorTag and coauthorName contains "claude" or "anthropic" (case-insensitive): Level = FullyAI, Confidence = 0.6 (lower confidence than daemon data)
  - Otherwise: Level = FullyHuman, Confidence = 0.8

Note: Move AuthorshipLevel constants to `internal/authorship/` since that's the canonical location. The correlator imports from authorship.
  </action>
  <verify>
    Run `go build ./...` -- zero errors.
    Run `go vet ./...` -- zero warnings.
    Verify schema version is 2 in schema.go.
    Verify attributions table DDL in migrations map.
    Verify Correlator has CorrelateFileEvent and CorrelateAll methods.
    Verify Classifier has Classify, ClassifyWithHistory, and ClassifyFromGit methods.
    Verify all 5 authorship levels are defined as constants.
  </verify>
  <done>
    Schema migration v2 adds attributions table with indexes. Store has query methods for file_events and session_events by time window plus InsertAttribution. Correlator matches file events to session events by time proximity (5s window, closest wins). Classifier assigns five-level authorship with confidence scores. Code compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for correlation engine and authorship classifier</name>
  <files>
    internal/correlation/correlator_test.go
    internal/authorship/classifier_test.go
  </files>
  <action>
**Correlation tests** (`internal/correlation/correlator_test.go`):

Use a mock StoreReader (define in test file) to avoid real SQLite dependency.

Test cases:
1. **Exact file match within 1s**: File event at T, session Write event for same file at T+500ms. Expect: MatchType="exact_file", TimeDeltaMs=500, MatchedSession != nil
2. **Exact file match closest wins**: File event at T, two session events for same file at T-3s and T+1s. Expect: T+1s is matched (closer)
3. **No session events**: File event with no session events in window. Expect: MatchType="none", MatchedSession=nil
4. **Time proximity fallback**: File event for "foo.go", no session events for foo.go, but Write event for "bar.go" at T+2s. Expect: MatchType="time_proximity"
5. **Outside window**: File event at T, session event at T+6s (outside 5s window). Expect: MatchType="none"
6. **CorrelateAll**: Multiple file events, returns results for each

**Authorship classifier tests** (`internal/authorship/classifier_test.go`):

Test cases:
1. **No match -> FullyHuman**: CorrelationResult with MatchType="none". Expect: Level=FullyHuman, Confidence=1.0
2. **Exact match <2s -> FullyAI**: TimeDelta=500ms, MatchType="exact_file". Expect: Level=FullyAI, Confidence=0.95
3. **Exact match 2-5s -> AIFirstHumanRevised**: TimeDelta=3000ms. Expect: Level=AIFirstHumanRevised, Confidence=0.7
4. **Time proximity -> AISuggestedHumanWritten**: MatchType="time_proximity". Expect: Level=AISuggestedHumanWritten, Confidence=0.5
5. **Low confidence -> Uncertain**: Result with Confidence < 0.5. Expect: Uncertain=true
6. **ClassifyWithHistory - human editing AI code**: Prior=FullyAI, current=no match. Expect: AIFirstHumanRevised
7. **ClassifyWithHistory - AI editing human code**: Prior=FullyHuman, current=exact match. Expect: HumanFirstAIRevised
8. **ClassifyWithHistory - no prior**: nil prior, falls through to Classify
9. **ClassifyFromGit - coauthor tag**: hasCoauthor=true, name contains "claude". Expect: FullyAI, Confidence=0.6
10. **ClassifyFromGit - no coauthor**: Expect: FullyHuman, Confidence=0.8
11. **First author wins**: Prior=AI-authored, new correlation has session match. FirstAuthor stays "ai" (first author set the direction)

Run all tests with `-race` flag.
  </action>
  <verify>
    Run `go test -race -v ./internal/correlation/...` -- all tests pass.
    Run `go test -race -v ./internal/authorship/...` -- all tests pass.
    Run `go test -race ./...` -- all existing tests still pass.
    Verify at least 6 test functions in correlator_test.go.
    Verify at least 9 test functions in classifier_test.go.
  </verify>
  <done>
    Correlation engine has 6+ tests covering exact match, closest-wins, no-match, time-proximity fallback, outside-window, and batch correlation. Authorship classifier has 9+ tests covering all five spectrum levels, uncertain marking, history-based classification, git-only classification, and first-author-wins. All pass with race detector.
  </done>
</task>

</tasks>

<verification>
Run the full verification sequence:
1. `go build ./...` compiles without errors
2. `go vet ./...` passes without warnings
3. `go test -race ./...` -- all tests pass (new + existing)
4. Schema version is 2, migration creates attributions table
5. At least 15 new tests across both packages
6. Correlator handles: exact match, closest-wins, no-match, time-proximity, outside-window
7. Classifier handles: all 5 authorship levels, uncertain, history, git-only
</verification>

<success_criteria>
- File events correlate to session events within a configurable time window (default 5s)
- Closest-in-time session event wins when multiple candidates exist
- No-match file events are classified as fully human
- Five authorship levels are assignable: fully_ai, ai_first_human_revised, human_first_ai_revised, ai_suggested_human_written, fully_human
- Confidence scores reflect match quality (0.95 for tight match, lower for proximity)
- Uncertain flag set when confidence < 0.5
- First-author-wins rule applied via ClassifyWithHistory
- Git-only fallback via ClassifyFromGit (lower confidence)
- Attributions table persists results
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligence/02-01-SUMMARY.md`
</output>
